<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Pixel F1 Racing HTML - Corrigido</title>
    <style>
        body {
            margin: 0;
            background: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        canvas {
            background: #444;
            border-left: 15px solid #1a3c1a;
            border-right: 15px solid #1a3c1a;
            background-image: linear-gradient(rgba(0, 0, 0, 0.1) 50%, transparent 50%);
            background-size: 100% 4px;
            box-shadow: 0 0 30px black;
            image-rendering: pixelated; 
        }
        #uiContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        #gameOver {
            position: absolute;
            display: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 4px solid red;
            z-index: 10;
        }
        h1 { margin: 0; color: red; font-size: 40px;}
        h2 { margin: 10px 0; }
    </style>
</head>
<body>

    <div id="uiContainer">
        <h2>Score: <span id="scoreDisplay">0</span></h2>
        <p>Speed: <span id="speedDisplay">1x</span></p>
    </div>

    <div id="gameOver">
        <h1>CRASH!</h1>
        <p>Fim da linha, piloto.</p>
        <p>Pressione <strong>F5</strong> para correr de novo.</p>
    </div>

    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; 

        const gameOverScreen = document.getElementById('gameOver');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const speedDisplay = document.getElementById('speedDisplay');

        // --- PREPARAÇÃO DO JOGO ---
        let gameRunning = true;
        let score = 0;
        let baseSpeed = 4;
        let currentSpeed = baseSpeed;
        let roadOffset = 0;

        const player = { x: 175, y: 500, width: 50, height: 80, dx: 7 };
        const keys = { ArrowLeft: false, ArrowRight: false };
        let obstacles = [];

        // Imagens
        const playerImg = new Image();
        const enemyImg = new Image();

        // CONTROLES
        document.addEventListener('keydown', (e) => { if(e.key in keys) keys[e.key] = true; });
        document.addEventListener('keyup', (e) => { if(e.key in keys) keys[e.key] = false; });

        // FUNÇÕES
        function spawnObstacle() {
            if (!gameRunning) return;
            const width = 50;
            const x = Math.random() * (canvas.width - width);
            obstacles.push({ x: x, y: -150, width: width, height: 80 });
            
            let spawnRate = 1500 / (currentSpeed / baseSpeed); 
            setTimeout(spawnObstacle, spawnRate + Math.random() * 500);
        }

        function checkCollision(rect1, rect2) {
            const marginX = 5;
            const marginY = 5;
            return (
                rect1.x + marginX < rect2.x + rect2.width - marginX &&
                rect1.x + rect1.width - marginX > rect2.x + marginX &&
                rect1.y + marginY < rect2.y + rect2.height - marginY &&
                rect1.y + rect1.height - marginY > rect2.y + marginY
            );
        }

        function update() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Pista
            roadOffset += currentSpeed;
            if (roadOffset > 80) roadOffset = 0;

            ctx.fillStyle = "rgba(255,255,255,0.8)";
            for(let i = -1; i < 10; i++) {
                let y = (i * 80) + roadOffset; 
                ctx.fillRect(195, y, 10, 40); 
                ctx.fillRect(10, y, 5, 40);
                ctx.fillRect(385, y, 5, 40);
            }

            // Jogador
            if (keys.ArrowLeft && player.x > 5) player.x -= player.dx;
            if (keys.ArrowRight && player.x < canvas.width - player.width - 5) player.x += player.dx;
            
            // Se a imagem não tiver carregado ainda, desenha quadrado azul (fallback)
            if (playerImg.complete) {
                ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = "blue";
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            // Obstáculos
            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.y += currentSpeed;

                if (enemyImg.complete) {
                    ctx.drawImage(enemyImg, obs.x, obs.y, obs.width, obs.height);
                } else {
                    ctx.fillStyle = "red";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                }
                
                // Filtro vermelho
                ctx.fillStyle = "rgba(200, 0, 0, 0.6)";
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                if (checkCollision(player, obs)) {
                    gameRunning = false;
                    gameOverScreen.style.display = 'block';
                }
            }

            // Pontuação
            if (obstacles.length > 0 && obstacles[0].y > canvas.height) {
                obstacles.shift();
                score++;
                scoreDisplay.innerText = score;
                currentSpeed = currentSpeed * 1.02;
                if (currentSpeed > 22) currentSpeed = 22;
                speedDisplay.innerText = (currentSpeed / baseSpeed).toFixed(1) + "x";
            }

            requestAnimationFrame(update);
        }

        // --- AQUI ESTÁ A CORREÇÃO PRINCIPAL ---
        // 1. Definimos o que fazer quando carregar
        playerImg.onload = () => {
             // Só inicia se ainda não tiver iniciado
             if(gameRunning && obstacles.length === 0) {
                 spawnObstacle();
                 update();
             }
        };

        // 2. DEPOIS definimos a fonte da imagem
        playerImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAYCAYAAADW7y+UAAAAAXNSR0IArs4c6QAAAEVJREFUOE9jZKAQcEIxAwXgPwwD/0k1hGE0zDAeBcMIApLSWCTFcaQYQhY7sShG1k+y43GkGEayE9FwREn0I8UwYgAAa5YgE+L+k5oAAAAASUVORK5CYII=';
        enemyImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAYCAYAAADW7y+UAAAAAXNSR0IArs4c6QAAAEVJREFUOE9jZKAQcEIxAwXgPwwD/0k1hGE0zDAeBcMIApLSWCTFcaQYQhY7sShG1k+y43GkGEayE9FwREn0I8UwYgAAa5YgE+L+k5oAAAAASUVORK5CYII=';

        // 3. Fallback de segurança: Se por acaso já estiver carregado (cache), força o início
        setTimeout(() => {
            if (playerImg.complete && obstacles.length === 0) {
                spawnObstacle();
                update();
            }
        }, 100);

    </script>
</body>
</html>